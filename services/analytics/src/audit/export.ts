/**
 * Compliance Export
 *
 * Creates signed ZIP bundles with:
 * - JSONL audit events
 * - SHA-256 manifest
 * - PDF cover summary
 *
 * Performance target: ≤2 MB/s sustained streaming
 */

import type { Pool } from 'pg';
import { createHash } from 'crypto';
import { Readable } from 'stream';
import archiver from 'archiver';
import type {
  ComplianceExportRequest,
  ComplianceExportMetadata,
  AuditEvent,
  AuditEventFilters,
} from '@teei/shared-types';
import { AuditQueryBuilder } from './query-builder.js';
import { redactAuditEvent } from './redaction.js';

/**
 * Generate PDF cover summary
 */
function generatePDFCover(metadata: ComplianceExportMetadata): string {
  // Simple PDF generation (in production, use a library like pdfkit)
  const pdf = `
%PDF-1.4
1 0 obj
<<
/Type /Catalog
/Pages 2 0 R
>>
endobj
2 0 obj
<<
/Type /Pages
/Kids [3 0 R]
/Count 1
>>
endobj
3 0 obj
<<
/Type /Page
/Parent 2 0 R
/MediaBox [0 0 612 792]
/Contents 4 0 R
/Resources <<
/Font <<
/F1 <<
/Type /Font
/Subtype /Type1
/BaseFont /Helvetica-Bold
>>
/F2 <<
/Type /Font
/Subtype /Type1
/BaseFont /Helvetica
>>
>>
>>
>>
endobj
4 0 obj
<<
/Length 500
>>
stream
BT
/F1 18 Tf
50 700 Td
(Compliance Audit Export) Tj
0 -30 Td
/F2 12 Tf
(Export ID: ${metadata.exportId}) Tj
0 -20 Td
(Tenant ID: ${metadata.tenantId}) Tj
0 -20 Td
(Period: ${metadata.from.toISOString()} to ${metadata.to.toISOString()}) Tj
0 -20 Td
(Generated: ${metadata.generatedAt.toISOString()}) Tj
0 -20 Td
(Generated By: ${metadata.generatedBy.email}) Tj
0 -20 Td
(Event Count: ${metadata.eventCount}) Tj
0 -20 Td
(SHA-256: ${metadata.sha256}) Tj
0 -40 Td
(This export contains audit log events for compliance purposes.) Tj
0 -20 Td
(All events have been redacted to remove secrets and sensitive information.) Tj
0 -20 Td
(The manifest file contains a cryptographic hash for verification.) Tj
ET
endstream
endobj
xref
0 5
0000000000 65535 f
0000000009 00000 n
0000000058 00000 n
0000000115 00000 n
0000000350 00000 n
trailer
<<
/Size 5
/Root 1 0 R
>>
startxref
900
%%EOF
`.trim();

  return pdf;
}

/**
 * Generate manifest file with SHA-256 hash
 */
async function generateManifest(
  metadata: ComplianceExportMetadata,
  eventsHash: string
): Promise<string> {
  const manifest = {
    exportId: metadata.exportId,
    tenantId: metadata.tenantId,
    dateRange: {
      from: metadata.from.toISOString(),
      to: metadata.to.toISOString(),
    },
    generatedAt: metadata.generatedAt.toISOString(),
    generatedBy: {
      id: metadata.generatedBy.id,
      email: metadata.generatedBy.email,
      role: metadata.generatedBy.role,
    },
    eventCount: metadata.eventCount,
    files: {
      'events.jsonl': {
        sha256: eventsHash,
        description: 'Audit events in JSONL format (one event per line)',
      },
      'cover.pdf': {
        description: 'Export cover page with summary information',
      },
    },
    verification: {
      instructions:
        'Verify integrity by computing SHA-256 of events.jsonl and comparing with the hash in this manifest.',
      command: 'sha256sum events.jsonl',
    },
    signature: metadata.signature,
  };

  return JSON.stringify(manifest, null, 2);
}

/**
 * Create compliance export ZIP bundle
 */
export async function createComplianceExport(
  db: Pool,
  request: ComplianceExportRequest,
  user: { id: string; email: string; role: string }
): Promise<{ stream: Readable; filename: string; metadata: ComplianceExportMetadata }> {
  const queryBuilder = new AuditQueryBuilder(db);
  const exportId = crypto.randomUUID();

  // Build filters
  const filters: AuditEventFilters = {
    tenantId: request.tenantId,
    from: request.from,
    to: request.to,
    ...request.filters,
  };

  // Create ZIP archive
  const archive = archiver('zip', {
    zlib: { level: 6 }, // Compression level
  });

  // Track event count and hash
  let eventCount = 0;
  const hash = createHash('sha256');
  const eventsLines: string[] = [];

  // Stream events and build JSONL
  for await (const batch of queryBuilder.streamEvents(filters, 1000)) {
    for (const event of batch) {
      const redacted = redactAuditEvent(event, request.maskPII || false);

      // Convert to JSONL (one JSON object per line)
      const line = JSON.stringify(redacted) + '\n';
      eventsLines.push(line);
      hash.update(line);
      eventCount++;
    }
  }

  const eventsJsonl = eventsLines.join('');
  const eventsHash = hash.digest('hex');

  // Create metadata
  const metadata: ComplianceExportMetadata = {
    exportId,
    tenantId: request.tenantId,
    from: request.from,
    to: request.to,
    generatedAt: new Date(),
    generatedBy: {
      id: user.id,
      email: user.email,
      role: user.role,
    },
    eventCount,
    sha256: eventsHash,
  };

  // Generate manifest and PDF cover
  const manifest = await generateManifest(metadata, eventsHash);
  const pdfCover = generatePDFCover(metadata);

  // Add files to archive
  archive.append(eventsJsonl, { name: 'events.jsonl' });
  archive.append(manifest, { name: 'manifest.json' });
  archive.append(pdfCover, { name: 'cover.pdf' });

  // Add README
  const readme = `
# Compliance Audit Export

Export ID: ${exportId}
Tenant ID: ${request.tenantId}
Period: ${request.from.toISOString()} to ${request.to.toISOString()}
Generated: ${new Date().toISOString()}
Event Count: ${eventCount}

## Files

- **events.jsonl**: Audit events in JSONL format (one JSON object per line)
- **manifest.json**: Export metadata and SHA-256 hash for verification
- **cover.pdf**: Cover page summary
- **README.md**: This file

## Verification

To verify the integrity of this export:

1. Compute the SHA-256 hash of events.jsonl:
   \`\`\`bash
   sha256sum events.jsonl
   \`\`\`

2. Compare the hash with the value in manifest.json

3. The hashes should match exactly

## Event Format

Each line in events.jsonl is a JSON object with the following structure:

\`\`\`json
{
  "id": "event-uuid",
  "timestamp": "ISO8601 datetime",
  "tenantId": "tenant-uuid",
  "actor": { "id": "user-uuid", "email": "user@example.com", "role": "role" },
  "resource": { "type": "resource_type", "id": "resource-uuid", "identifier": "human-readable" },
  "action": "ACTION_NAME",
  "actionCategory": "CATEGORY",
  "before": { /* state before action */ },
  "after": { /* state after action */ },
  "origin": { "ip": "IP address", "userAgent": "User agent", "requestId": "request-uuid" },
  "metadata": { /* additional context */ }
}
\`\`\`

## Data Redaction

${request.maskPII ? '✓ PII has been masked in this export' : '✗ PII has NOT been masked (full export)'}
✓ Secrets and API keys have been redacted

## Questions?

For questions about this export, contact your compliance team.
`.trim();

  archive.append(readme, { name: 'README.md' });

  // Finalize archive
  archive.finalize();

  const filename = `audit_export_${request.tenantId}_${request.from
    .toISOString()
    .split('T')[0]}_${request.to.toISOString().split('T')[0]}.zip`;

  return {
    stream: archive as any,
    filename,
    metadata,
  };
}
