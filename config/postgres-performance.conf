# ============================================================================
# PostgreSQL Performance & Slow Query Configuration
# SWARM 12: Analytics Hardening - Agent 1.7 (slow-query-logger)
# ============================================================================
# Purpose: Enable comprehensive query performance monitoring
# Include: Add 'include = 'config/postgres-performance.conf'' to postgresql.conf
# ============================================================================

# ------------------------------------------------------------------------------
# SLOW QUERY LOGGING
# ------------------------------------------------------------------------------

# Log queries that take longer than 1 second
log_min_duration_statement = 1000  # milliseconds

# Detailed logging for performance analysis
log_line_prefix = '%t [%p]: [%l-1] user=%u,db=%d,app=%a,client=%h '
log_duration = off  # Don't log all query durations (use log_min_duration_statement instead)
log_statement = 'none'  # Don't log all statements (too verbose)

# Log long lock waits (helps identify contention)
log_lock_waits = on
deadlock_timeout = 1s  # How long to wait before checking for deadlock

# Log temporary file usage (indicates work_mem too small)
log_temp_files = 0  # Log all temp files (any size)

# Log checkpoints and autovacuum
log_checkpoints = on
log_autovacuum_min_duration = 0  # Log all autovacuum operations

# Connection logging (for audit/security)
log_connections = on
log_disconnections = on

# ------------------------------------------------------------------------------
# pg_stat_statements EXTENSION (Query Performance Tracking)
# ------------------------------------------------------------------------------

# Required: Add pg_stat_statements to shared_preload_libraries
# This must be done in postgresql.conf and requires PostgreSQL restart
# shared_preload_libraries = 'pg_stat_statements'

# pg_stat_statements configuration
pg_stat_statements.max = 10000  # Track up to 10,000 distinct queries
pg_stat_statements.track = all  # Track all queries (not just top-level)
pg_stat_statements.track_utility = on  # Track utility commands (CREATE INDEX, VACUUM, etc.)
pg_stat_statements.track_planning = on  # Track planning time (PostgreSQL 13+)

# ------------------------------------------------------------------------------
# AUTO_EXPLAIN (Automatic EXPLAIN for Slow Queries)
# ------------------------------------------------------------------------------

# Optional: Enable auto_explain for automatic EXPLAIN plans
# Uncomment to enable (requires restart)
# shared_preload_libraries = 'pg_stat_statements,auto_explain'

# auto_explain.log_min_duration = 1000  # EXPLAIN queries >1 second
# auto_explain.log_analyze = on  # Include actual execution statistics
# auto_explain.log_buffers = on  # Include buffer usage
# auto_explain.log_timing = on  # Include per-node timing
# auto_explain.log_triggers = on  # Include trigger statistics
# auto_explain.log_verbose = on  # Include verbose output
# auto_explain.log_nested_statements = on  # Log nested statements (functions)

# ------------------------------------------------------------------------------
# QUERY PLANNING & OPTIMIZATION
# ------------------------------------------------------------------------------

# Enable parallel query execution
max_parallel_workers_per_gather = 4  # Default: 2 (increase for analytics queries)
max_parallel_workers = 8  # Total parallel workers across all queries
max_worker_processes = 8  # Background worker limit

# Enable JIT compilation for complex queries (PostgreSQL 11+)
jit = on  # Just-In-Time compilation for expressions
jit_above_cost = 100000  # Only JIT for expensive queries
jit_inline_above_cost = 500000
jit_optimize_above_cost = 500000

# Query planner configuration
default_statistics_target = 100  # Default: 100 (increase to 500 for analytics columns)
random_page_cost = 1.1  # Default: 4.0 (lower for SSD, higher for HDD)
effective_cache_size = 12GB  # 75% of total RAM (adjust based on server)
shared_buffers = 4GB  # 25% of total RAM (adjust based on server)
work_mem = 50MB  # Per-operation memory (sort, hash join)
maintenance_work_mem = 1GB  # Memory for VACUUM, CREATE INDEX

# ------------------------------------------------------------------------------
# VACUUMING & STATISTICS
# ------------------------------------------------------------------------------

# Autovacuum tuning for high-write tables (audit_logs, ai_token_usage)
autovacuum_max_workers = 3  # Default: 3
autovacuum_naptime = 30s  # Default: 1min (more frequent for high churn)

# Vacuum threshold for large tables
autovacuum_vacuum_scale_factor = 0.05  # Default: 0.2 (trigger at 5% dead tuples)
autovacuum_analyze_scale_factor = 0.025  # Default: 0.1 (analyze at 2.5% changes)

# Vacuum cost limiting (prevent I/O starvation)
autovacuum_vacuum_cost_delay = 10ms  # Default: 20ms (lower = faster vacuum)
autovacuum_vacuum_cost_limit = 2000  # Default: 200 (higher = more aggressive)

# ------------------------------------------------------------------------------
# WAL (Write-Ahead Log) TUNING
# ------------------------------------------------------------------------------

# WAL size and checkpoints (balance between crash recovery and performance)
wal_buffers = 16MB  # Default: -1 (auto, typically 3% of shared_buffers)
checkpoint_timeout = 10min  # Default: 5min (increase for less frequent checkpoints)
checkpoint_completion_target = 0.9  # Default: 0.5 (spread checkpoint I/O)
max_wal_size = 4GB  # Default: 1GB (increase for high-write workloads)
min_wal_size = 1GB  # Default: 80MB

# WAL archiving (for point-in-time recovery)
# archive_mode = on  # Enable for production
# archive_command = 'test ! -f /mnt/wal_archive/%f && cp %p /mnt/wal_archive/%f'

# ------------------------------------------------------------------------------
# CONNECTION POOLING
# ------------------------------------------------------------------------------

# Connection limits (adjust based on expected load)
max_connections = 200  # Default: 100 (increase for microservices)
superuser_reserved_connections = 3  # Reserved for superuser access

# Connection pooling with PgBouncer is HIGHLY RECOMMENDED
# See /k8s/base/pgbouncer/ for deployment configuration

# ------------------------------------------------------------------------------
# LOGGING OUTPUT FORMAT
# ------------------------------------------------------------------------------

# Log destination
log_destination = 'stderr'  # or 'jsonlog' for structured logs (PostgreSQL 15+)
logging_collector = on  # Enable log file rotation
log_directory = '/var/log/postgresql'
log_filename = 'postgresql-%Y-%m-%d.log'
log_file_mode = 0640
log_rotation_age = 1d  # Rotate daily
log_rotation_size = 100MB  # Rotate at 100 MB
log_truncate_on_rotation = off  # Append, don't overwrite

# CSV logging for pgBadger analysis
# log_destination = 'csvlog'
# log_filename = 'postgresql-%Y-%m-%d.csv'

# ------------------------------------------------------------------------------
# MONITORING & STATISTICS
# ------------------------------------------------------------------------------

# Track query execution statistics
track_activities = on  # Track currently running queries
track_counts = on  # Track table/index access counts
track_io_timing = on  # Track I/O timing (slight overhead, worth it)
track_functions = all  # Track function call statistics

# Update statistics aggressively for analytics queries
stats_temp_directory = '/var/run/postgresql'  # Use tmpfs for speed

# ------------------------------------------------------------------------------
# SECURITY
# ------------------------------------------------------------------------------

# SSL/TLS (enable for production)
# ssl = on
# ssl_cert_file = '/etc/postgresql/ssl/server.crt'
# ssl_key_file = '/etc/postgresql/ssl/server.key'
# ssl_ca_file = '/etc/postgresql/ssl/ca.crt'

# Prevent privilege escalation
# shared_preload_libraries = 'pg_stat_statements'  # Only load trusted libraries

# ------------------------------------------------------------------------------
# SWARM 12 SPECIFIC TUNING
# ------------------------------------------------------------------------------

# Optimize for VIS/SROI/Q2Q analytics workload
# - Heavy GROUP BY and aggregation queries
# - Multi-table JOINs (3-4 tables)
# - Time-range filtering on large tables

# Increase work_mem for complex aggregations
# CONSIDER: Set per-session for analytics queries
# SET work_mem = '256MB';  # For VIS/SROI calculations

# Enable parallel aggregation
enable_parallel_hash = on  # Parallel hash joins
enable_partitionwise_aggregate = on  # Parallel aggregation on partitions

# Disable for faster INSERTs (OLTP vs OLAP trade-off)
# synchronous_commit = off  # WARNING: May lose last few transactions on crash

# ------------------------------------------------------------------------------
# NOTES
# ------------------------------------------------------------------------------
#
# 1. Some settings require PostgreSQL restart:
#    - shared_preload_libraries
#    - shared_buffers
#    - max_connections
#    - wal_buffers
#
# 2. Reload configuration without restart:
#    sudo systemctl reload postgresql
#    -- OR --
#    SELECT pg_reload_conf();
#
# 3. View current settings:
#    SELECT name, setting, unit, context FROM pg_settings WHERE name LIKE '%log%';
#
# 4. Enable pg_stat_statements:
#    -- Step 1: Add to postgresql.conf
#    shared_preload_libraries = 'pg_stat_statements'
#    -- Step 2: Restart PostgreSQL
#    sudo systemctl restart postgresql
#    -- Step 3: Create extension
#    CREATE EXTENSION IF NOT EXISTS pg_stat_statements;
#
# 5. Monitoring queries:
#    -- Top 10 slowest queries
#    SELECT query, calls, total_exec_time, mean_exec_time
#    FROM pg_stat_statements
#    ORDER BY total_exec_time DESC
#    LIMIT 10;
#
# ==============================================================================
